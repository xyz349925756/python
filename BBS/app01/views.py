import jsonimport os.pathimport timefrom django.db.models import Countfrom django.shortcuts import render, HttpResponse, redirectfrom django.contrib import authfrom django.db.models.functions import TruncMonth# Create your views here.from app01.register_forms import Register_Formsfrom app01 import modelsfrom django.http import JsonResponse# forms 表单# def register(request):#     form_obj = Register_Forms()#     if request.method == 'POST':#         back_dic = {'code':8888,'msg':''}#         form_obj = Register_Forms(request.POST)#         # print(form_obj.is_valid())#         # 判断数据是否合法#         if form_obj.is_valid():#             clean_data = form_obj.cleaned_data#             # 移除多余的字段confirm_password,否则写入数据会报错#             clean_data.pop('confirm_password')#             # 将校验通过的数据赋值给一个字典#             models.UserInfo.objects.create_user(**clean_data)#             return redirect('/login/')#     return render(request, 'register.html', locals())# form_ajaxdef register_ajax(request):    form_obj = Register_Forms()    if request.method == 'POST':        back_dic = {"code": 8888, 'msg': ''}  # 使用ajax 序列化需要使用字典        form_obj = Register_Forms(request.POST)        if form_obj.is_valid():            clean_data = form_obj.cleaned_data            clean_data.pop('confirm_password')            # 获取用户头像            avatar_obj = request.FILES.get('avatar')            # print(avatar_obj,type(avatar_obj))  #<class 'django.core.files.uploadedfile.InMemoryUploadedFile'>            """            如果这里传了none空值,就会清空默认值,头像就不会显示默认值了            """            if avatar_obj:                clean_data['avatar'] = avatar_obj            # 保存数据            models.UserInfo.objects.create_user(**clean_data)            back_dic['url'] = '/login/'        else:            back_dic['code'] = 4444            back_dic['msg'] = form_obj.errors        return JsonResponse(back_dic)    return render(request, 'register_ajax.html', locals())def login(request):    if request.method == 'POST':        back_dic = {'code': 8888, 'msg': ''}  # Ajax序列化必须是dict        username = request.POST.get('username')        password = request.POST.get('password')        code = request.POST.get('code')        if request.session.get('code').upper() == code.upper():            user_obj = auth.authenticate(request, username=username, password=password)            # print(user_obj)            if user_obj:                auth.login(request, user_obj)                back_dic['url'] = '/'            else:                back_dic['code'] = 4444                back_dic['msg'] = '用户名或密码错误'        else:            back_dic['code'] = 2222            back_dic['msg'] = '验证码错误'        return JsonResponse(back_dic)    return render(request, 'login.html')from PIL import Image, ImageDraw, ImageFont"""image: 生成图片imagedraw : 能够在图片上涂鸦imagefont : 控制字体样式"""from io import BytesIO, StringIO"""内存管理器模块BytesIO:临时存储数据,返回数据是二进制StringIO:临时帮你存储数据,返回的时候是字符串"""import randomdef get_random():    return random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)def get_code(request):    # 第一种方法 直接获取后端现成的图片二进制数据发送给前端    # with open(r'static/avatar/default.png','rb') as f:    #     data = f.read()    # return HttpResponse(data)    # 第二种 利用pillow模块动态产生图片    # img_obj = Image.new('RGB',(100,57),'green')    # img_obj = Image.new('RGB',(100,57),get_random())  # 随机颜色 100,57是外面框的长宽属性    # with open(r'xxx.png','wb') as f:   # 先将图片对象保存起来    #     img_obj.save(f,'png')    # with open(r'xxx.png','rb') as f:   # 再将图片对象读取出来    #     data = f.read()    # return HttpResponse(data)    # 第三种 内存管理器模块    # img_obj = Image.new('RGB',(100,57),get_random())    # io_obj = BytesIO()  # 生成一个内存管理器对象,可以堪称文件句柄    # img_obj.save(io_obj,'png')    # return HttpResponse(io_obj.getvalue()) # 从内存管理器读取出二进制图片数据.    # 第四种 图片验证码    img_obj = Image.new('RGB', (100, 57), get_random())    img_draw = ImageDraw.Draw(img_obj)  # 产生一个画笔对象    img_font = ImageFont.truetype('static/font/FiraCode-Light.ttf', 30)  # 字体样式 大小    # 随机验证码  五位数的随机验证码  数字 小写字母 大写字母    code = ''    for i in range(5):        random_upper = chr(random.randint(65, 90))  # 大写        random_lower = chr(random.randint(97, 122))  # 小写        random_int = chr(random.randint(48, 57))  # 数字 这里面是acsii码不是十进制        # 从上面三个里面随机选择一个        tmp = random.choice([random_upper, random_lower, random_int])        # 将产生的随机字符串写入到图片上        """            为什么一个个写而不是生成好了之后再写             因为一个个写能够控制每个字体的间隙 而生成好之后再写的话             间隙就没法控制了        """        # img_draw.text((0,0),tmp,get_random(),img_font) # 写死的位置        img_draw.text((i * 20, 10, -2), tmp, get_random(), img_font)        code += tmp    print(code)    request.session['code'] = code  # 连接到login    io_obj = BytesIO()    img_obj.save(io_obj, 'png')    return HttpResponse(io_obj.getvalue())from django.contrib.auth.decorators import login_required@login_requireddef edit_password(request):    if request.headers.get('x-requested-with') == 'XMLHttpRequest':  # 取代is_ajax        back_dic = {'code': 888, 'msg': ''}        if request.method == 'POST':            old_password = request.POST.get('old_password')            new_password = request.POST.get('new_password')            confirm_password = request.POST.get('confirm_password')            is_right = request.user.check_password(old_password)            if is_right:                if new_password == old_password:                    back_dic['code'] = 333                    back_dic['msg'] = '新密码不能与原密码一致'                else:                    if new_password == confirm_password:                        request.user.set_password(new_password)                        request.user.save()                        back_dic['msg'] = '修改成功'                    else:                        back_dic['code'] = 444                        back_dic['msg'] = '两次密码不一致'            else:                back_dic['code'] = 222                back_dic['msg'] = '原密码错误'        return JsonResponse(back_dic)@login_requireddef logout(request):    auth.logout(request)    return redirect('/')from app01.utils.Capage import Paginationdef home(request):    article_queryset = models.Article.objects.all()  #    current_page = request.GET.get('page', 1)    all_count = article_queryset.count()    per_page_num = 6    if all_count % per_page_num == 0:        pager_count = int(all_count / per_page_num)    else:        pager_count = int(all_count / per_page_num) + 1    page_obj = Pagination(current_page=current_page, all_count=all_count, per_page_num=per_page_num,                          pager_count=pager_count)    page_queryset = article_queryset[page_obj.start:page_obj.end]    return render(request, 'index.html', locals())def site(request, username, **kwargs):    """    :param request:    :param username:    :param kwargs:  如果该参数有值 也就意味着对article_list做额外的筛选操作    :return:    """    # 校验当前用户名对应的个人站点是否存在    user_obj = models.UserInfo.objects.filter(username=username).first()    # print(user_obj)    # 如果不存在返回404    if not user_obj:        return render(request, '404.html')    # 个人站点    blog = user_obj.blog    # 查询当前个人站点下的所有文章    article_list = models.Article.objects.filter(blog=blog)    # print('kwargs',kwargs) # 判断多传入的参数是否存在    # 筛选    if kwargs:        # print(kwargs)        condition = kwargs.get('condition')        param = kwargs.get('param')        if condition == 'category':            article_list = article_list.filter(category_id=param)        elif condition == 'tag':            article_list = article_list.filter(tags__id=param)        else:            year, month = param.split('-')            article_list = article_list.filter(create_time__year=year, create_time__month=month)    # 分页    current_page = request.GET.get('page', 1)    all_count = article_list.count()    per_page_num = 10    if all_count % per_page_num == 0:        pager_count = int(all_count / per_page_num)    else:        pager_count = int(all_count / per_page_num) + 1    apage_obj = Pagination(current_page=current_page, all_count=all_count, per_page_num=per_page_num,                           pager_count=pager_count)    article_page_queryset = article_list[apage_obj.start:apage_obj.end]    return render(request, 'site.html', locals())def article_detail(request, username, article_id):    user_obj = models.UserInfo.objects.filter(username=username).first()    blog = user_obj.blog    article_obj = models.Article.objects.filter(pk=article_id, blog__userinfo__username=username).first()    if not article_obj:        return render(request, '404.html')    comment_list = models.Comment.objects.filter(article=article_obj)    return render(request, 'article_detail.html', locals())from django.db.models import Fdef up_or_down(request):    if request.headers.get('x-requested-with') == 'XMLHttpRequest':  # 取代is_ajax        back_dic = {'code': 1, 'msg': ''}        # print(request.user.is_authenticated)  # 判断是否登录        if request.user.is_authenticated:            article_id = request.POST.get('article_id')            is_up = request.POST.get('is_up')  # true <class 'str'>            is_up = json.loads(is_up)  # True <class 'bool'>            # print(is_up, type(is_up))            # 判断当前文章是否是当前用户自己的            article_obj = models.Article.objects.filter(pk=article_id).first()            if not article_obj.blog.userinfo == request.user:                # 校验用户是否已经点过了. upanddown中记录了点赞信息                is_click = models.UpAndDown.objects.filter(user=request.user, article=article_obj)                if not is_click:                    # 如果没有点赞就可以点赞,操作数据库了.                    if is_up:                        models.Article.objects.filter(pk=article_id).update(up_num=F('up_num') + 1)                        back_dic['msg'] = '赞了一票'                    else:                        models.Article.objects.filter(pk=article_id).update(down_num=F('down_num') + 1)                        back_dic['msg'] = '踩了一下'                    # 操作点赞表                    models.UpAndDown.objects.create(user=request.user, article=article_obj, is_up=is_up)                else:                    back_dic['code'] = 2                    back_dic['msg'] = '您已经点过,不能再点'            else:                back_dic['code'] = 3                back_dic['msg'] = '你不能给自己点赞,点踩!'        else:            back_dic['code'] = 4            back_dic['msg'] = '请先<a href="/login/">登录</a>'        return JsonResponse(back_dic)from django.db import transactiondef comment(request):    if request.headers.get('x-requested-with') == 'XMLHttpRequest':        back_dic = {'code': 10, 'msg': ''}        if request.method == 'POST':            if request.user.is_authenticated:                article_id = request.POST.get('article_id')                content = request.POST.get('content')                parent_id = request.POST.get('parent_id')  # 子评论                # print(article_id,content,parent_id)                with transaction.atomic():                    models.Article.objects.filter(pk=article_id).update(comment_num=F('comment_num') + 1)                    models.Comment.objects.create(user=request.user, article_id=article_id, content=content,                                                  parent_id=parent_id)                back_dic['msg'] = '评论成功'            else:                back_dic['code'] = 11                back_dic['msg'] = '用户未登录'            return JsonResponse(back_dic)def error(request):    return render(request, '404.html')@login_requireddef badmin(request):    global pager_count    article_list = models.Article.objects.filter(blog=request.user.blog)    # 分页    current_page = request.GET.get('page', 1)    all_count = article_list.count()    per_page_num = 11    if all_count % per_page_num == 0:        pager_count = int(all_count / per_page_num)    else:        pager_count = int(all_count / per_page_num) + 1    page_obj = Pagination(current_page=current_page, all_count=all_count, per_page_num=per_page_num,                          pager_count=pager_count)    page_queryset = article_list[page_obj.start:page_obj.end]    return render(request, 'admin/badmin.html', locals())from bs4 import BeautifulSoup@login_requireddef add_article(request):    # print(request.user.blog)    if request.method == 'POST':        title = request.POST.get('title')        content = request.POST.get('content')        category_id = request.POST.get('category')        tag_id_list = request.POST.get('tag')        # print(tag_id_list,title,content,category_id)        # modle        soup = BeautifulSoup(content, 'html.parser')        tags = soup.find_all()        #  all tag        for tag in tags:            # print(i.name)            if tag.name == 'script':                tag.decompose()        desc = soup.text[0:150]        article_obj = models.Article.objects.create(            title=title,            content=str(soup),            desc=desc,            category_id=category_id,            blog=request.user.blog        )        article_obj_list = []        for i in tag_id_list:            tag_article_obj = models.Article2Tag(article=article_obj, tag_id=i)            article_obj_list.append(tag_article_obj)        # 批量插入数据        models.Article2Tag.objects.bulk_create(article_obj_list)        return redirect('/badmin/')    category_list = models.Category.objects.filter(blog=request.user.blog)    tag_list = models.Tag.objects.filter(blog=request.user.blog)    # print(tag_list)    return render(request, 'admin/add_article.html', locals())@login_requireddef add_suibi(request):    # print(request.user.blog)    if request.method == 'POST':        title = request.POST.get('title')        content = request.POST.get('content')        category_id = request.POST.get('category')        tag_id_list = request.POST.get('tag')        # print(tag_id_list,title,content,category_id)        # modle        soup = BeautifulSoup(content, 'html.parser')        tags = soup.find_all()        #  all tag        for tag in tags:            # print(i.name)            if tag.name == 'script':                tag.decompose()        desc = soup.text[0:150]        # desc = content.text[0:150]        article_obj = models.Article.objects.create(            title=title,            content=str(soup),            # content=str(content),            desc=desc,            category_id=category_id,            blog=request.user.blog        )        article_obj_list = []        for i in tag_id_list:            tag_article_obj = models.Article2Tag(article=article_obj, tag_id=i)            article_obj_list.append(tag_article_obj)        # 批量插入数据        models.Article2Tag.objects.bulk_create(article_obj_list)        return redirect('/badmin/')    category_list = models.Category.objects.filter(blog=request.user.blog)    tag_list = models.Tag.objects.filter(blog=request.user.blog)    # print(tag_list)    return render(request, 'admin/add_article.html', locals())from django.conf import settingsdef upload_image(request):    """     {      "success": true/false,      "msg": "error message", # optional      "file_path": "[real file path]"    }    """    back_dic = {}    if request.method == 'POST':        image = request.FILES.get('upload_image')        # print(image,type(image))  # 2.jpg <class 'django.core.files.uploadedfile.InMemoryUploadedFile'>        # print(image.name.split('.')[-1])  #jpg        # file_dir = os.path.join(settings.BASE_DIR,'media','images')        if image.name.split('.')[-1] in ['jpg', 'jpeg', 'png', 'bmp', 'gif']:            file_dir = os.path.join(settings.BASE_DIR, 'media', 'images')  # F:\Django_Project_Dir\BBS\media\images            # print(f"文件目录:{file_dir}")            if not os.path.isdir(file_dir):  # 如果目录不存在就创建目录                os.mkdir(file_dir)            file_path = os.path.join(file_dir, image.name)  # 上传的image路径            file_path1 = settings.MEDIA_URL + image.name  # 使用浏览器访问已保存图片的全称            # print(file_path,file_path1)            with open(file_path, 'wb') as img:                # for line in image:                for line in image:                    img.write(line)            back_dic["success"] = True            back_dic["msg"] = "上传成功"            back_dic["file_path"] = file_path1        else:            back_dic["success"] = False            back_dic["msg"] = "您上传的不是图片,请重新上传"  # http://www.seogao.com/article/6.html            # back_dic["file_path"] = "image_path"    return JsonResponse(back_dic)@login_requireddef delete_article(request):    # def delete_article(request, del_id):    # 第一种方法    # data = models.Article.objects.filter(pk=del_id)    # if data.filter(up_num__gt=0) and data.filter(down_num__gt=0) and data.filter(comment_num__gt=0):    #     models.UpAndDown.objects.filter(pk=del_id).delete()    #     models.Comment.objects.filter(pk=del_id).delete()    #     data.delete()    # else:    #     data.delete()    # return redirect('badmin')    # 第二种    if request.headers.get('x-requested-with') == 'XMLHttpRequest':        if request.method == 'POST':            back_dic = {                'code': 88,                'msg': ''            }            time.sleep(3)            del_id = request.POST.get('del_id')            data = models.Article.objects.filter(pk=del_id)            data1 = data.first().title            if data.filter(up_num__gt=0) and data.filter(down_num__gt=0) and data.filter(comment_num__gt=0):                models.UpAndDown.objects.filter(pk=del_id).delete()                models.Comment.objects.filter(pk=del_id).delete()                data.delete()            else:                data.delete()            back_dic['msg'] = f'<{data1}> 已删除'            return JsonResponse(back_dic)@login_requireddef set_avatar(request):    if request.method == 'POST':        file_obj = request.FILES.get('avatar')        user_obj = request.user        user_obj.avatar = file_obj        user_obj.save()        return redirect('/home/')    blog = request.user.blog    username = request.user.username    return render(request, 'set_avater.html', locals())@login_requireddef edit_article(request,edit_id):    if request.method == 'POST':        # title = article_obj        content = request.POST.get('content')        # category_id = request.POST.get('category')        # tag_id_list = request.POST.get('tag')        soup = BeautifulSoup(content,'html.parser')        tags = soup.find_all()        for tag in tags:            if tag.name == 'script':                tag.decompose()        desc = soup.text[0:150]        article_update_obj = models.Article.objects.filter(blog=request.user.blog).filter(pk=edit_id).update(            content=str(soup),            desc=desc,            # category_id=category_id,            # blog=request.user.blog        )        # article_obj_list = []        # for i in tag_id_list:            # tag_article_obj = models.Article2Tag(article=article_update_obj,tag_id=i)            # article_obj_list.append(tag_article_obj)        # models.Article2Tag.objects.bulk_update(article_obj_list)        return redirect('/badmin/')    article_obj = models.Article.objects.filter(blog=request.user.blog).filter(pk=edit_id).first()    category_obj = models.Category.objects.filter(blog=request.user.blog)    tag_obj = models.Tag.objects.filter(blog=request.user.blog)    # 这里不加filter(blog=request.user.blog)  其他用户也可以编辑别人的文档.    return render(request,'admin/edit_article.html',locals())